// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tasks.sql

package gosql_queries

import (
	"context"
	"database/sql"
)

const addTask = `-- name: AddTask :exec
INSERT INTO tasks (
	id, description, due_date, state, subject_id, academic_value
) VALUES ( ?, ?, datetime(?), ?, ?, ? )
`

type AddTaskParams struct {
	ID            string
	Description   string
	Datetime      interface{}
	State         string
	SubjectID     string
	AcademicValue sql.NullFloat64
}

func (q *Queries) AddTask(ctx context.Context, arg AddTaskParams) error {
	_, err := q.db.ExecContext(ctx, addTask,
		arg.ID,
		arg.Description,
		arg.Datetime,
		arg.State,
		arg.SubjectID,
		arg.AcademicValue,
	)
	return err
}

const deleteTask = `-- name: DeleteTask :exec
DELETE FROM tasks WHERE id = ?
`

func (q *Queries) DeleteTask(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteTask, id)
	return err
}

const getAllTasksBySubject = `-- name: GetAllTasksBySubject :many
SELECT id, description, state, due_date, subject_id, is_urgent, is_important, academic_value, created_at, updated_at FROM tasks
WHERE subject_id = ?
`

func (q *Queries) GetAllTasksBySubject(ctx context.Context, subjectID string) ([]Task, error) {
	rows, err := q.db.QueryContext(ctx, getAllTasksBySubject, subjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.Description,
			&i.State,
			&i.DueDate,
			&i.SubjectID,
			&i.IsUrgent,
			&i.IsImportant,
			&i.AcademicValue,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLastTaskID = `-- name: GetLastTaskID :one
SELECT id FROM tasks
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetLastTaskID(ctx context.Context) (string, error) {
	row := q.db.QueryRowContext(ctx, getLastTaskID)
	var id string
	err := row.Scan(&id)
	return id, err
}

const getTaskByID = `-- name: GetTaskByID :one
SELECT id, description, state, due_date, subject_id, is_urgent, is_important, academic_value, created_at, updated_at FROM tasks
WHERE id = ?
`

func (q *Queries) GetTaskByID(ctx context.Context, id string) (Task, error) {
	row := q.db.QueryRowContext(ctx, getTaskByID, id)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.Description,
		&i.State,
		&i.DueDate,
		&i.SubjectID,
		&i.IsUrgent,
		&i.IsImportant,
		&i.AcademicValue,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const modifyTaskAcademicValue = `-- name: ModifyTaskAcademicValue :execrows
UPDATE tasks SET
academic_value = ?,
updated_at = datetime('now', 'localtime')
WHERE id = ?
`

type ModifyTaskAcademicValueParams struct {
	AcademicValue sql.NullFloat64
	ID            string
}

func (q *Queries) ModifyTaskAcademicValue(ctx context.Context, arg ModifyTaskAcademicValueParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, modifyTaskAcademicValue, arg.AcademicValue, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const modifyTaskDescription = `-- name: ModifyTaskDescription :execrows
UPDATE tasks SET
description = ?,
updated_at = datetime('now', 'localtime')
WHERE id = ?
`

type ModifyTaskDescriptionParams struct {
	Description string
	ID          string
}

func (q *Queries) ModifyTaskDescription(ctx context.Context, arg ModifyTaskDescriptionParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, modifyTaskDescription, arg.Description, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const modifyTaskDueDate = `-- name: ModifyTaskDueDate :execrows
UPDATE tasks SET
due_date = datetime(?),
updated_at = datetime('now', 'localtime')
WHERE id = ?
`

type ModifyTaskDueDateParams struct {
	Datetime interface{}
	ID       string
}

func (q *Queries) ModifyTaskDueDate(ctx context.Context, arg ModifyTaskDueDateParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, modifyTaskDueDate, arg.Datetime, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const modifyTaskState = `-- name: ModifyTaskState :execrows
UPDATE tasks SET
state = ?,
updated_at = datetime('now', 'localtime')
WHERE id = ?
`

type ModifyTaskStateParams struct {
	State string
	ID    string
}

func (q *Queries) ModifyTaskState(ctx context.Context, arg ModifyTaskStateParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, modifyTaskState, arg.State, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const toggleTaskImportantState = `-- name: ToggleTaskImportantState :execrows
UPDATE tasks SET
is_important = CASE WHEN is_important = 1 THEN 0 ELSE 1 END,
updated_at = datetime('now', 'localtime')
WHERE id = ?
`

func (q *Queries) ToggleTaskImportantState(ctx context.Context, id string) (int64, error) {
	result, err := q.db.ExecContext(ctx, toggleTaskImportantState, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const toggleTaskUrgentState = `-- name: ToggleTaskUrgentState :execrows
UPDATE tasks SET
is_urgent = CASE WHEN is_urgent = 1 THEN 0 ELSE 1 END,
updated_at = datetime('now', 'localtime')
WHERE id = ?
`

func (q *Queries) ToggleTaskUrgentState(ctx context.Context, id string) (int64, error) {
	result, err := q.db.ExecContext(ctx, toggleTaskUrgentState, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
